{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyconfme \ud83d\udd17 Python module to have all configuration options when creating command-line applications with click. Documentation \ud83d\udd17 See Github Pages","title":"Overview"},{"location":"#pyconfme","text":"Python module to have all configuration options when creating command-line applications with click.","title":"pyconfme"},{"location":"#documentation","text":"See Github Pages","title":"Documentation"},{"location":"development/","text":"Development \ud83d\udd17 Development Computer Setup (Example) \ud83d\udd17 This section describes an example development computer environment. The environment as described below has been used in the initial setup of the project. We assume a Mac-computer with latest macOS installed (at the time of writing this it's macOS Big Sur 11.6.1). On this computer, the following tools could be used: Docker Desktop >4.2.0 (70708) for macOS from Docker Hub . A very good Docker tutorial may help in using Docker. Git >2.21.0 for macOS from git homepage iTerm2 >3.4.12 as terminal from iterm2 homepage Firefox >94.0.1 as browser from Mozilla website Visual Studio Code (VS Code) >1.62.3 as editor from VSC homepage Visual Studio Code plugins: Python Beautify Bracket Pair Colorizer 2 Docker GitLens PrintCode Remote - Containers Todo Tree YAML markdownlint REST Client Rewrap vscode-icons Even Better TOML REST Client Markdown Preview Mermaid Support Check diagramming support with Mermaid for markdown (in VS Code preview) by testing with the following mardown code: ```mermaid graph TD; A-->B; A-->C; B-->D; C-->D; ``` graph TD; A-->B; A-->C; B-->D; C-->D; Preview the markdown in VSCode on macOS eihter by pressing Command+Shift+V (on Windows CTRL+Shift+V ) or by showing side-by-side with Command+K V (on Windows CTRL+K V ). Note: A good Markdown Cheatsheet . Versioning \ud83d\udd17 Semantic versioning is used, following the rules of SemVer . Specifically, the following applies: Development phase starts with 0.1.0 and increments minor and patch until a first stable, production-ready version is reached. Git tags are prefixed with \"v\" in this project, so \u201cv1.2.3\u201d is a tag name and the semantic version is \u201c1.2.3\u201d Branching Strategy \ud83d\udd17 The branching strategy tries to be as lean as possible, but still allow for a structured approach for as small team. It follows the following rules: \"main\" branch always contains the latest official stable, production-ready release; it always contains the release path of the highest major release according to semantic versioning. For each major release, a development branch exists, using the naming \"dev-x.0.0\", where x corresponds to the release branch developed for. The first development branch is \"dev-0.0.0\" until the first major release is done (\"1.0.0\"). Then, the development branch \"dev-1.0.0\" is created, where development continues. From version \"1.0.0\" onwards, all releases are merged into the \"main\" branch, but only for the latest development branch. Example: If \"dev-1.0.0\" and \"dev-2.0.0\" exist, where \"dev-1.0.0\" is an older release, which might still be undo support with security patches, \"dev-2.0.0\" represents the latest release, whose release are merged to \"main\". graph LR; subgraph main main0((0.0.0)) ------ main1((0.1.0)) ---- main2((1.0.0)) ---- main3((1.0.1)) ---- main4((1.1.0)) ---- main5((2.0.0)); end subgraph dev-0.0.0 dev0(( )) --- dev1(( )) --- dev2(( )) --- dev3(( )) --- dev4(( )) --- dev5(( )); end subgraph dev-1.0.0 dev10(( )) --- dev11(( )) --- dev12(( )) --- dev13(( )) --- dev14(( )) --- dev15(( )); end main0 --- dev0; dev3 --- main1; dev5 --- main2; main2 --- dev10; dev11 --- main3; dev12 --- main4; dev15 --- main5; Github Project Setup \ud83d\udd17 On GitHub's webinterface, the project pyconfme was created as fresh project with minimal initial files: .gitignore (GitHub's template for Python), License and Readme-file. In GitHub's webinterface, the branch \"dev-0.0.0\" was created from \"main\"-branch. All initial development takes place in \"dev-0.0.0\" until the first stable release. Local Working Environment \ud83d\udd17 In your projects' folder, check out the remote git-repository: git clone https://github.com/bnaard/pyconfme.git Then switch into current development branch (here as an example the branch dev-0.0.0 ): cd pyconfme git checkout dev-0.0.0 Then open the project's folder in VSCode with the function \"Open in Container...\". The first time, the container is opened, choose the following initial options: Python 3.9 (OS \"bullseye\" at the time of writing) no nodejs environment no other additional software added to the image Then set up the main configuration files of VS Code as follows and run \"Rebuild Container...\". Dockerfile # [Choice] Python version (use -bullseye variants on local arm64/Apple Silicon): 3, 3.10, 3.9, 3.8, 3.7, 3.6, 3-bullseye, 3.10-bullseye, 3.9-bullseye, 3.8-bullseye, 3.7-bullseye, 3.6-bullseye, 3-buster, 3.10-buster, 3.9-buster, 3.8-buster, 3.7-buster, 3.6-buster ARG VARIANT = \"3.9-bullseye\" FROM mcr.microsoft.com/vscode/devcontainers/python:0- ${ VARIANT } # Install dependency/virtual-environment-management tool RUN pip install poetry RUN poetry config virtualenvs.create true devcontainer.json { \"name\" : \"Python 3\" , \"build\" : { \"dockerfile\" : \"Dockerfile\" , \"context\" : \"..\" , \"args\" : { // Update 'VARIANT' to pick a Python version : 3 , 3.10 , 3.9 , 3.8 , 3.7 , 3.6 // Append - bullseye or - buster to pin to an OS version . // Use - bullseye variants on local on arm64 / Apple Silicon . \"VARIANT\" : \"3.9-bullseye\" , // Options \"NODE_VERSION\" : \"none\" } }, // Set * default * container specific settings . json values on container create . \"settings\" : { \"python.defaultInterpreterPath\" : \"/usr/local/bin/python\" , \"python.linting.enabled\" : true , \"python.linting.pylintEnabled\" : true , \"python.formatting.autopep8Path\" : \"/usr/local/py-utils/bin/autopep8\" , \"python.formatting.blackPath\" : \"/usr/local/py-utils/bin/black\" , \"python.formatting.yapfPath\" : \"/usr/local/py-utils/bin/yapf\" , \"python.linting.banditPath\" : \"/usr/local/py-utils/bin/bandit\" , \"python.linting.flake8Path\" : \"/usr/local/py-utils/bin/flake8\" , \"python.linting.mypyPath\" : \"/usr/local/py-utils/bin/mypy\" , \"python.linting.pycodestylePath\" : \"/usr/local/py-utils/bin/pycodestyle\" , \"python.linting.pydocstylePath\" : \"/usr/local/py-utils/bin/pydocstyle\" , \"python.linting.pylintPath\" : \"/usr/local/py-utils/bin/pylint\" }, // Add the IDs of extensions you want installed when the container is created . \"extensions\" : [ \"ms-python.python\" , \"ms-python.vscode-pylance\" , \"ms-azuretools.vscode-docker\" , \"tamasfe.even-better-toml\" , \"eamodio.gitlens\" , \"davidanson.vscode-markdownlint\" , \"humao.rest-client\" , \"gruntfuggly.todo-tree\" , \"redhat.vscode-yaml\" , \"bierner.markdown-mermaid\" ], // Use 'forwardPorts' to make a list of ports inside the container available locally . \"forwardPorts\" : [ 8000 ], // Use 'postCreateCommand' to run commands after the container is created . // \"postCreateCommand\" : \"pip3 install --user -r requirements.txt\" , // Comment out connect as root instead . More info : https : // aka . ms / vscode - remote / containers / non - root . \"remoteUser\" : \"vscode\" } Build Tool \ud83d\udd17 General \ud83d\udd17 The project's dependencies, build-chain and deployment to PyPI is managed with Python Poetry . Main project information is manged in file pyproject.toml Dependencies to the production are added by poetry add <pypi-package-name> or removed by poetry remove <pypi-package-name> Dependencies only needed for development are added by poetry add --dev <pypi-package-name> or removed by poetry remove --dev <pypi-package-name> In case of problems, it usually helps to manually delete the automatically generated poetry.lock -file and to run poetry install to reinstall all dependencies with recalculation of dependency tree. Version Management \ud83d\udd17 Versioning is managed also by Python Poetry using SemVer : Major version update: poetry version major (for large releases with completely new feature sets and/or breakting API) Minor version update: poetry version minor (for minor feature additions and/or non-breaking api changes) Patch version update: poetry version patch (for bugfixes, minor documentation updates) Though versioning is managed with Python Poetry , the version definition needs manual update in the following steps and locations: Major/Minor/Patch version update using one of the above poetry version commands Manual update of pyconfme/__init__.py:__version__ Manual update of command for rebuilding the documentation (only for preview locally, production versioning is handled in Github actions). See section Documentation below. Setup \ud83d\udd17 In VS Code with the project's folder opened in a container, initiate the Poetry project and create a virtual environment. Make sure you are in the pyconfme project root directory. In there run the Poetry init command that will bootstrap all configuration files. poetry init Answer the questions of the project creation wizard to create an initial pyproject.toml file: Package name [pyconfme]: <ENTER> Version [0.1.0]: 0.0.0 <ENTER> Description []: Configuration options with multiple config-files and command-line made easy when creating applications with Python Click. <ENTER> Author [John Doe <john.doe@internet.com>: <ENTER> License []: MIT <ENTER> Compatible Python versions [^3.9]: <ENTER> Would you like to define your main dependencies interactively? (yes/no) [yes] no <ENTER> Would you like to define your development dependencies interactively? (yes/no) [yes] no <ENTER> Do you confirm generation? (yes/no) [yes] <ENTER> Then add from command-line all production dependencies. pydantic Data validation and settings management using python type annotations. click Command Line Interface Creation Kit python-dotenv Reads key-value pairs from a .env file and can set them as environment variables PyYAML YAML framework toml Parsing and creating TOML poetry add pydantic click python-dotenv pyyaml toml Add all the development dependencies needed for testing, documentation and code review. poethepoet A task runner that works well with poetry pylint Python linter black The uncompromising Python code formatter mypy static type checker for Python pytest (Unit) Test Framework pytest-cov Coverage plugin for pytest. pytest-html Plugin for generating HTML reports for pytest results hypothesis Fuzzy-testing for pytest mkdocs Project documentation with Markdown mkdocs-material Material design for mkdocs markdown-include Provides syntax for Python-Markdown which allows for the inclusion of the contents of other Markdown documents mkdocs-exclude A mkdocs plugin that lets you exclude files or trees from your output mkdocstrings Automatic documentation from sources, for MkDocs mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build mkdocs-pdf-export-plugin An MkDocs plugin to export content pages as PDF files mkdocs-mermaid2-plugin A Mermaid graphs plugin for mkdocs mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site asciinema recording terminal sessions mike Manage multiple versions of your MkDocs-powered documentation via Git poetry add --dev poethepoet pylint black mypy pytest pytest-cov pytest-html hypothesis mkdocs mkdocs-material markdown-include mkdocs-exclude mkdocstrings mkdocs-gen-files mkdocs-pdf-export-plugin mkdocs-mermaid2-plugin mkdocs-coverage asciinema mike The above commands install all dependencies inside the VS Code container. Also the virtualenv resides inside the container. This is to encapsulate the dependencies, specifically to not clutter the host system with large directory trees. However, this requires re-installing all dependencies with poetry init , if you rebuild the container, which may take long. If you prefer to keep the dependencies on the host-system, you need to create the virtualenv managed by Poetry inside the project's directory. To instruct Poetry to do so, run poetry config virtualenvs.in-project true . See Poetry documentation . Configuration \ud83d\udd17 To configure all development dependencies, add to the pyproject.toml file the following sections. Configuring pytest output formatting and register plugins ( doctest -plugin to test code in Python docstrings and coverage plugin to measure test-coverage). [tool.pytest.ini_options] log_cli = true log_cli_level = \"DEBUG\" log_cli_format = \"%(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)\" log_cli_date_format = \"%Y-%m-%d %H:%M:%S\" addopts = \"--doctest-modules\" [tool.pytest] addopts = \"--cov=$(pwd) --cov-report html\" Configuring coverage plugin to include the source-code directory only (and not eg the test-directory or and existing virtual-environment). [tool.coverage.paths] source = [ \"pyconfme\" ] [tool.coverage.run] omit = [ \"tests/*\" , \".venv/*\" ] Configuring pylint maximum line-length. [tool.pylint] max-line-length = 88 Configuring black code formatter to same line-length as pylint and to some common-sense include/exclude rules. [tool.black] experimental-string-processing = true line-length = 88 target-version = [ 'py39' ] include = '\\.pyi?$' exclude = ''' ( /( \\.eggs # exclude a few common directories in the | \\.git # root of the project | \\.hg | \\.mypy_cache | \\.tox | \\.venv | _build | buck-out | build | dist )/ | foo.py # also separately exclude a file named foo.py in # the root of the project ) ''' Configure poethepoet task runner extension with some convenience commands. poe t for running tests poe covtest for running tests including coverage measurement poe covreport to get html-coverage report from latest coverage measurement poe ct to run both sequentially, tests including coverage measurement and coverage report creation poe db to (re-)build the documentation using the _VERSION variable to determine documentation version poe d serve documentation locally with mike 's test-server. Go to http://localhost:8000 in your local browser [tool.poe.env] _VERSION = \"v0.1.0\" [tool.poe.tasks] t = \"pytest\" covtest = \"coverage run -m pytest\" covreport = \"coverage html\" ct = [ \"covtest\" , \"covreport\" ] db = [ { cmd = \"mike deploy $_VERSION\" }, { cmd = \"mike set-default $_VERSION\" }, { cmd = \"mike alias $_VERSION latest\" } ] d = \"mike serve\" clean = \"\"\" rm -rf .coverage html_cov .mypy_cache .pytest_cache .hypothesis dist site ./**/__pycache__ \"\"\" Documentation \ud83d\udd17 General \ud83d\udd17 Documentation is build using mkdocs static page generator with several plugins which allow versioning, integration of docstring comments and deploying to Github pages . The advantages of this approach are greater flexibility in page setup and design, integration of docstring comments and examples and simple local preview. The main plugins are: For design, search and navigation: mkdocs-material For integration of docstring comments: mkdoc-strings For versioning: mike Setup \ud83d\udd17 The documentation creation with mkdocs is managed through the config file mkdocs.yml , which contains general site-parameters (eg. title, theme), site structure and plugin-configuration. Initial mkdocs.yml content: site_name : pyconfme site_description : Configuration options with multiple config-files and command-line made easy when creating applications with [Python Click](https://click.palletsprojects.com). strict : true site_url : https://bnaard.github.io/pyconfme/ theme : name : 'material' custom_dir : 'docs/theme' palette : primary : blue accent : blue # logo: 'logo-white.svg' # favicon: 'favicon.png' repo_name : bnaard/oyconfme repo_url : https://github.com/bnaard/pyconfme nav : - Overview : index.md markdown_extensions : - markdown_include.include : base_path : docs - toc : permalink : \ud83d\udd17 - pymdownx.highlight - pymdownx.extra - admonition - pymdownx.details - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:pymdownx.superfences.fence_div_format - pymdownx.emoji - pymdownx.magiclink - pymdownx.snippets : check_paths : true - pymdownx.tabbed - pymdownx.tasklist plugins : - search # - pdf-export - autorefs - coverage : page_name : coverage # default html_report_dir : htmlcov - mkdocstrings : handlers : python : rendering : show_root_heading : no show_category_heading : no show_if_no_docstring : yes - exclude : glob : - _build/* - build/* - examples/* - requirements.txt extra : version : provider : mike extra_css : - stylesheets/asciinema-player.css extra_javascript : - javascripts/asciinema-player.js - https://unpkg.com/mermaid/dist/mermaid.min.js Manually add the JavaScript and CSS static assets for asciinema-player as it is not distrubuted on a CDN at the time of writing this. Download asciinema-player.min.js from Asciinema releases page and store in .\\docs\\javascripts Download asciinema-player.css from Asciinema releases page and store in .\\docs\\stylesheets This dependency has to be manually updated as it is not managed through poetry . Github Hosting \ud83d\udd17 We use Github for serving the static build of the documentation websites. For that, GitHub Pages have to be enabled and our configuration has to ensure that Github does not try to use its standard-renderer jekyll to build our documentation. Instead, we instruct Github to serve pages as is without rendering. To do so, we first enable Guthub pages, then we disable the standard renderer jekyll . Create a dedicated branch for the built documentation: in Github webinterface create a new branch gh-pages from main branch To enable Github pages: go to Github repository web-interface go to Settings tab select Pages in the left box select as Source the branch gh-pages and select \\root as folder click Save and ignore for now that Github reports that the documentation build fails Instruct Github to not use standard renderer jekyll : place an empty file named .nojekyll in the root directory of the built documentation All productive documentation is hosted on gh-pages -branch of this repository. This is automatically managed and overwritten by the mkdoc -tools mentioned above. So, do not edit manually the gh-pages -branch as all your changes will be overwritten and lost on next documentation auto-build+deploy. Github Actions \ud83d\udd17 build (here: a pipeline of linting and running all tests) and docs (here: document creation with mkdocs ) are implemented as Github actions. Both actions are setup in Github webinterface. Initial content build.yml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions # For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions name : Build on : push : branches : [ main ] pull_request : branches : [ main ] jobs : build : runs-on : ubuntu-latest strategy : matrix : python-version : [ 3.7 , 3.8 , 3.9 ] steps : - uses : actions/checkout@v2 - name : Set up Python ${{ matrix.python-version }} uses : actions/setup-python@v2 with : python-version : ${{ matrix.python-version }} - name : Install dependencies run : | python -m pip install --upgrade pip python -m pip install poetry poetry config virtualenvs.in-project true poetry install # if [ -f requirements.txt ]; then pip install -r requirements.txt; fi - name : Lint with pylint run : | python lint.py --path ./pyconfme --threshold 2 continue-on-error : true - name : Test with pytest run : | ./.venv/bin/pytest --doctest-modules --html=test-results-${{ matrix.python-version }}.html --cov-report=html --cov=./pyconfme/ . continue-on-error : true - name : Upload pytest test results uses : actions/upload-artifact@v2 with : path : | test-results-${{ matrix.python-version }}.html assets/* - name : Upload test coverage results uses : actions/upload-artifact@v2 with : path : ./htmlcov # Use always() to always run this step to publish test results when there are test failures if : ${{ always() }} Initial content docs.yml name : Docs on : push : branches : - main jobs : deploy : runs-on : ubuntu-18.04 strategy : matrix : python-version : [ '3.9' ] steps : - uses : actions/checkout@v2 - name : Set up Python ${{ matrix.python-version }} uses : actions/setup-python@v2 with : python-version : ${{ matrix.python-version }} - name : Install dependencies run : | python -m pip install --upgrade pip python -m pip install poetry poetry config virtualenvs.in-project true poetry install - uses : actions-ecosystem/action-get-latest-tag@v1 id : get-latest-tag with : semver_only : true - run : | export PATH=\"$PATH:$PWD/.venv/bin\" git config --global user.name \"$(git --no-pager log --format=format:'%an' -n 1)\" git config --global user.email \"$(git --no-pager log --format=format:'%ae' -n 1)\" mike deploy --update-aliases ${{ steps.get-latest-tag.outputs.tag }} latest mike set-default latest - name : Deploy uses : peaceiris/actions-gh-pages@v3 with : github_token : ${{ secrets.GITHUB_TOKEN }} publish_dir : ./site The Github action described in .github/workflows/docs.yml is based on GitHub Actions for GitHub Pages , which builds and deploys mkdoc page structures and takes care that Github is serving those as is instead of using Jekyll. In the Github actions, the latest version is retrieved using get-latest-tag to build the latest documentation. While documentation updates including documentation versions on Github are automatically done based on latest tag information (see .github/workflows/Docs.yml ), you need to run the following to locally build and serve the versioned documentation for preview on https://localhost:8000 : mike deploy --update-aliases 0 .1.0 latest # replace 0.1.0 manually with the current version from pyconfme/__init__.py mike set-default latest mike serve You have to run both commands to get a proper redirect to the latest documentation on https://localhost:8000 . Refer to mkdocs-material documentation and to mike documentation for details. Instead of running mike deploy manually, you can use the poethepoet actions described earlier. Create a test-build of the documentation by changing into the virtual-environment and then using the poe build task for the documentation. poetry shell poe db","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#development-computer-setup-example","text":"This section describes an example development computer environment. The environment as described below has been used in the initial setup of the project. We assume a Mac-computer with latest macOS installed (at the time of writing this it's macOS Big Sur 11.6.1). On this computer, the following tools could be used: Docker Desktop >4.2.0 (70708) for macOS from Docker Hub . A very good Docker tutorial may help in using Docker. Git >2.21.0 for macOS from git homepage iTerm2 >3.4.12 as terminal from iterm2 homepage Firefox >94.0.1 as browser from Mozilla website Visual Studio Code (VS Code) >1.62.3 as editor from VSC homepage Visual Studio Code plugins: Python Beautify Bracket Pair Colorizer 2 Docker GitLens PrintCode Remote - Containers Todo Tree YAML markdownlint REST Client Rewrap vscode-icons Even Better TOML REST Client Markdown Preview Mermaid Support Check diagramming support with Mermaid for markdown (in VS Code preview) by testing with the following mardown code: ```mermaid graph TD; A-->B; A-->C; B-->D; C-->D; ``` graph TD; A-->B; A-->C; B-->D; C-->D; Preview the markdown in VSCode on macOS eihter by pressing Command+Shift+V (on Windows CTRL+Shift+V ) or by showing side-by-side with Command+K V (on Windows CTRL+K V ). Note: A good Markdown Cheatsheet .","title":"Development Computer Setup (Example)"},{"location":"development/#versioning","text":"Semantic versioning is used, following the rules of SemVer . Specifically, the following applies: Development phase starts with 0.1.0 and increments minor and patch until a first stable, production-ready version is reached. Git tags are prefixed with \"v\" in this project, so \u201cv1.2.3\u201d is a tag name and the semantic version is \u201c1.2.3\u201d","title":"Versioning"},{"location":"development/#branching-strategy","text":"The branching strategy tries to be as lean as possible, but still allow for a structured approach for as small team. It follows the following rules: \"main\" branch always contains the latest official stable, production-ready release; it always contains the release path of the highest major release according to semantic versioning. For each major release, a development branch exists, using the naming \"dev-x.0.0\", where x corresponds to the release branch developed for. The first development branch is \"dev-0.0.0\" until the first major release is done (\"1.0.0\"). Then, the development branch \"dev-1.0.0\" is created, where development continues. From version \"1.0.0\" onwards, all releases are merged into the \"main\" branch, but only for the latest development branch. Example: If \"dev-1.0.0\" and \"dev-2.0.0\" exist, where \"dev-1.0.0\" is an older release, which might still be undo support with security patches, \"dev-2.0.0\" represents the latest release, whose release are merged to \"main\". graph LR; subgraph main main0((0.0.0)) ------ main1((0.1.0)) ---- main2((1.0.0)) ---- main3((1.0.1)) ---- main4((1.1.0)) ---- main5((2.0.0)); end subgraph dev-0.0.0 dev0(( )) --- dev1(( )) --- dev2(( )) --- dev3(( )) --- dev4(( )) --- dev5(( )); end subgraph dev-1.0.0 dev10(( )) --- dev11(( )) --- dev12(( )) --- dev13(( )) --- dev14(( )) --- dev15(( )); end main0 --- dev0; dev3 --- main1; dev5 --- main2; main2 --- dev10; dev11 --- main3; dev12 --- main4; dev15 --- main5;","title":"Branching Strategy"},{"location":"development/#github-project-setup","text":"On GitHub's webinterface, the project pyconfme was created as fresh project with minimal initial files: .gitignore (GitHub's template for Python), License and Readme-file. In GitHub's webinterface, the branch \"dev-0.0.0\" was created from \"main\"-branch. All initial development takes place in \"dev-0.0.0\" until the first stable release.","title":"Github Project Setup"},{"location":"development/#local-working-environment","text":"In your projects' folder, check out the remote git-repository: git clone https://github.com/bnaard/pyconfme.git Then switch into current development branch (here as an example the branch dev-0.0.0 ): cd pyconfme git checkout dev-0.0.0 Then open the project's folder in VSCode with the function \"Open in Container...\". The first time, the container is opened, choose the following initial options: Python 3.9 (OS \"bullseye\" at the time of writing) no nodejs environment no other additional software added to the image Then set up the main configuration files of VS Code as follows and run \"Rebuild Container...\". Dockerfile # [Choice] Python version (use -bullseye variants on local arm64/Apple Silicon): 3, 3.10, 3.9, 3.8, 3.7, 3.6, 3-bullseye, 3.10-bullseye, 3.9-bullseye, 3.8-bullseye, 3.7-bullseye, 3.6-bullseye, 3-buster, 3.10-buster, 3.9-buster, 3.8-buster, 3.7-buster, 3.6-buster ARG VARIANT = \"3.9-bullseye\" FROM mcr.microsoft.com/vscode/devcontainers/python:0- ${ VARIANT } # Install dependency/virtual-environment-management tool RUN pip install poetry RUN poetry config virtualenvs.create true devcontainer.json { \"name\" : \"Python 3\" , \"build\" : { \"dockerfile\" : \"Dockerfile\" , \"context\" : \"..\" , \"args\" : { // Update 'VARIANT' to pick a Python version : 3 , 3.10 , 3.9 , 3.8 , 3.7 , 3.6 // Append - bullseye or - buster to pin to an OS version . // Use - bullseye variants on local on arm64 / Apple Silicon . \"VARIANT\" : \"3.9-bullseye\" , // Options \"NODE_VERSION\" : \"none\" } }, // Set * default * container specific settings . json values on container create . \"settings\" : { \"python.defaultInterpreterPath\" : \"/usr/local/bin/python\" , \"python.linting.enabled\" : true , \"python.linting.pylintEnabled\" : true , \"python.formatting.autopep8Path\" : \"/usr/local/py-utils/bin/autopep8\" , \"python.formatting.blackPath\" : \"/usr/local/py-utils/bin/black\" , \"python.formatting.yapfPath\" : \"/usr/local/py-utils/bin/yapf\" , \"python.linting.banditPath\" : \"/usr/local/py-utils/bin/bandit\" , \"python.linting.flake8Path\" : \"/usr/local/py-utils/bin/flake8\" , \"python.linting.mypyPath\" : \"/usr/local/py-utils/bin/mypy\" , \"python.linting.pycodestylePath\" : \"/usr/local/py-utils/bin/pycodestyle\" , \"python.linting.pydocstylePath\" : \"/usr/local/py-utils/bin/pydocstyle\" , \"python.linting.pylintPath\" : \"/usr/local/py-utils/bin/pylint\" }, // Add the IDs of extensions you want installed when the container is created . \"extensions\" : [ \"ms-python.python\" , \"ms-python.vscode-pylance\" , \"ms-azuretools.vscode-docker\" , \"tamasfe.even-better-toml\" , \"eamodio.gitlens\" , \"davidanson.vscode-markdownlint\" , \"humao.rest-client\" , \"gruntfuggly.todo-tree\" , \"redhat.vscode-yaml\" , \"bierner.markdown-mermaid\" ], // Use 'forwardPorts' to make a list of ports inside the container available locally . \"forwardPorts\" : [ 8000 ], // Use 'postCreateCommand' to run commands after the container is created . // \"postCreateCommand\" : \"pip3 install --user -r requirements.txt\" , // Comment out connect as root instead . More info : https : // aka . ms / vscode - remote / containers / non - root . \"remoteUser\" : \"vscode\" }","title":"Local Working Environment"},{"location":"development/#build-tool","text":"","title":"Build Tool"},{"location":"development/#general","text":"The project's dependencies, build-chain and deployment to PyPI is managed with Python Poetry . Main project information is manged in file pyproject.toml Dependencies to the production are added by poetry add <pypi-package-name> or removed by poetry remove <pypi-package-name> Dependencies only needed for development are added by poetry add --dev <pypi-package-name> or removed by poetry remove --dev <pypi-package-name> In case of problems, it usually helps to manually delete the automatically generated poetry.lock -file and to run poetry install to reinstall all dependencies with recalculation of dependency tree.","title":"General"},{"location":"development/#version-management","text":"Versioning is managed also by Python Poetry using SemVer : Major version update: poetry version major (for large releases with completely new feature sets and/or breakting API) Minor version update: poetry version minor (for minor feature additions and/or non-breaking api changes) Patch version update: poetry version patch (for bugfixes, minor documentation updates) Though versioning is managed with Python Poetry , the version definition needs manual update in the following steps and locations: Major/Minor/Patch version update using one of the above poetry version commands Manual update of pyconfme/__init__.py:__version__ Manual update of command for rebuilding the documentation (only for preview locally, production versioning is handled in Github actions). See section Documentation below.","title":"Version Management"},{"location":"development/#setup","text":"In VS Code with the project's folder opened in a container, initiate the Poetry project and create a virtual environment. Make sure you are in the pyconfme project root directory. In there run the Poetry init command that will bootstrap all configuration files. poetry init Answer the questions of the project creation wizard to create an initial pyproject.toml file: Package name [pyconfme]: <ENTER> Version [0.1.0]: 0.0.0 <ENTER> Description []: Configuration options with multiple config-files and command-line made easy when creating applications with Python Click. <ENTER> Author [John Doe <john.doe@internet.com>: <ENTER> License []: MIT <ENTER> Compatible Python versions [^3.9]: <ENTER> Would you like to define your main dependencies interactively? (yes/no) [yes] no <ENTER> Would you like to define your development dependencies interactively? (yes/no) [yes] no <ENTER> Do you confirm generation? (yes/no) [yes] <ENTER> Then add from command-line all production dependencies. pydantic Data validation and settings management using python type annotations. click Command Line Interface Creation Kit python-dotenv Reads key-value pairs from a .env file and can set them as environment variables PyYAML YAML framework toml Parsing and creating TOML poetry add pydantic click python-dotenv pyyaml toml Add all the development dependencies needed for testing, documentation and code review. poethepoet A task runner that works well with poetry pylint Python linter black The uncompromising Python code formatter mypy static type checker for Python pytest (Unit) Test Framework pytest-cov Coverage plugin for pytest. pytest-html Plugin for generating HTML reports for pytest results hypothesis Fuzzy-testing for pytest mkdocs Project documentation with Markdown mkdocs-material Material design for mkdocs markdown-include Provides syntax for Python-Markdown which allows for the inclusion of the contents of other Markdown documents mkdocs-exclude A mkdocs plugin that lets you exclude files or trees from your output mkdocstrings Automatic documentation from sources, for MkDocs mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build mkdocs-pdf-export-plugin An MkDocs plugin to export content pages as PDF files mkdocs-mermaid2-plugin A Mermaid graphs plugin for mkdocs mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site asciinema recording terminal sessions mike Manage multiple versions of your MkDocs-powered documentation via Git poetry add --dev poethepoet pylint black mypy pytest pytest-cov pytest-html hypothesis mkdocs mkdocs-material markdown-include mkdocs-exclude mkdocstrings mkdocs-gen-files mkdocs-pdf-export-plugin mkdocs-mermaid2-plugin mkdocs-coverage asciinema mike The above commands install all dependencies inside the VS Code container. Also the virtualenv resides inside the container. This is to encapsulate the dependencies, specifically to not clutter the host system with large directory trees. However, this requires re-installing all dependencies with poetry init , if you rebuild the container, which may take long. If you prefer to keep the dependencies on the host-system, you need to create the virtualenv managed by Poetry inside the project's directory. To instruct Poetry to do so, run poetry config virtualenvs.in-project true . See Poetry documentation .","title":"Setup"},{"location":"development/#configuration","text":"To configure all development dependencies, add to the pyproject.toml file the following sections. Configuring pytest output formatting and register plugins ( doctest -plugin to test code in Python docstrings and coverage plugin to measure test-coverage). [tool.pytest.ini_options] log_cli = true log_cli_level = \"DEBUG\" log_cli_format = \"%(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)\" log_cli_date_format = \"%Y-%m-%d %H:%M:%S\" addopts = \"--doctest-modules\" [tool.pytest] addopts = \"--cov=$(pwd) --cov-report html\" Configuring coverage plugin to include the source-code directory only (and not eg the test-directory or and existing virtual-environment). [tool.coverage.paths] source = [ \"pyconfme\" ] [tool.coverage.run] omit = [ \"tests/*\" , \".venv/*\" ] Configuring pylint maximum line-length. [tool.pylint] max-line-length = 88 Configuring black code formatter to same line-length as pylint and to some common-sense include/exclude rules. [tool.black] experimental-string-processing = true line-length = 88 target-version = [ 'py39' ] include = '\\.pyi?$' exclude = ''' ( /( \\.eggs # exclude a few common directories in the | \\.git # root of the project | \\.hg | \\.mypy_cache | \\.tox | \\.venv | _build | buck-out | build | dist )/ | foo.py # also separately exclude a file named foo.py in # the root of the project ) ''' Configure poethepoet task runner extension with some convenience commands. poe t for running tests poe covtest for running tests including coverage measurement poe covreport to get html-coverage report from latest coverage measurement poe ct to run both sequentially, tests including coverage measurement and coverage report creation poe db to (re-)build the documentation using the _VERSION variable to determine documentation version poe d serve documentation locally with mike 's test-server. Go to http://localhost:8000 in your local browser [tool.poe.env] _VERSION = \"v0.1.0\" [tool.poe.tasks] t = \"pytest\" covtest = \"coverage run -m pytest\" covreport = \"coverage html\" ct = [ \"covtest\" , \"covreport\" ] db = [ { cmd = \"mike deploy $_VERSION\" }, { cmd = \"mike set-default $_VERSION\" }, { cmd = \"mike alias $_VERSION latest\" } ] d = \"mike serve\" clean = \"\"\" rm -rf .coverage html_cov .mypy_cache .pytest_cache .hypothesis dist site ./**/__pycache__ \"\"\"","title":"Configuration"},{"location":"development/#documentation","text":"","title":"Documentation"},{"location":"development/#general_1","text":"Documentation is build using mkdocs static page generator with several plugins which allow versioning, integration of docstring comments and deploying to Github pages . The advantages of this approach are greater flexibility in page setup and design, integration of docstring comments and examples and simple local preview. The main plugins are: For design, search and navigation: mkdocs-material For integration of docstring comments: mkdoc-strings For versioning: mike","title":"General"},{"location":"development/#setup_1","text":"The documentation creation with mkdocs is managed through the config file mkdocs.yml , which contains general site-parameters (eg. title, theme), site structure and plugin-configuration. Initial mkdocs.yml content: site_name : pyconfme site_description : Configuration options with multiple config-files and command-line made easy when creating applications with [Python Click](https://click.palletsprojects.com). strict : true site_url : https://bnaard.github.io/pyconfme/ theme : name : 'material' custom_dir : 'docs/theme' palette : primary : blue accent : blue # logo: 'logo-white.svg' # favicon: 'favicon.png' repo_name : bnaard/oyconfme repo_url : https://github.com/bnaard/pyconfme nav : - Overview : index.md markdown_extensions : - markdown_include.include : base_path : docs - toc : permalink : \ud83d\udd17 - pymdownx.highlight - pymdownx.extra - admonition - pymdownx.details - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:pymdownx.superfences.fence_div_format - pymdownx.emoji - pymdownx.magiclink - pymdownx.snippets : check_paths : true - pymdownx.tabbed - pymdownx.tasklist plugins : - search # - pdf-export - autorefs - coverage : page_name : coverage # default html_report_dir : htmlcov - mkdocstrings : handlers : python : rendering : show_root_heading : no show_category_heading : no show_if_no_docstring : yes - exclude : glob : - _build/* - build/* - examples/* - requirements.txt extra : version : provider : mike extra_css : - stylesheets/asciinema-player.css extra_javascript : - javascripts/asciinema-player.js - https://unpkg.com/mermaid/dist/mermaid.min.js Manually add the JavaScript and CSS static assets for asciinema-player as it is not distrubuted on a CDN at the time of writing this. Download asciinema-player.min.js from Asciinema releases page and store in .\\docs\\javascripts Download asciinema-player.css from Asciinema releases page and store in .\\docs\\stylesheets This dependency has to be manually updated as it is not managed through poetry .","title":"Setup"},{"location":"development/#github-hosting","text":"We use Github for serving the static build of the documentation websites. For that, GitHub Pages have to be enabled and our configuration has to ensure that Github does not try to use its standard-renderer jekyll to build our documentation. Instead, we instruct Github to serve pages as is without rendering. To do so, we first enable Guthub pages, then we disable the standard renderer jekyll . Create a dedicated branch for the built documentation: in Github webinterface create a new branch gh-pages from main branch To enable Github pages: go to Github repository web-interface go to Settings tab select Pages in the left box select as Source the branch gh-pages and select \\root as folder click Save and ignore for now that Github reports that the documentation build fails Instruct Github to not use standard renderer jekyll : place an empty file named .nojekyll in the root directory of the built documentation All productive documentation is hosted on gh-pages -branch of this repository. This is automatically managed and overwritten by the mkdoc -tools mentioned above. So, do not edit manually the gh-pages -branch as all your changes will be overwritten and lost on next documentation auto-build+deploy.","title":"Github Hosting"},{"location":"development/#github-actions","text":"build (here: a pipeline of linting and running all tests) and docs (here: document creation with mkdocs ) are implemented as Github actions. Both actions are setup in Github webinterface. Initial content build.yml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions # For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions name : Build on : push : branches : [ main ] pull_request : branches : [ main ] jobs : build : runs-on : ubuntu-latest strategy : matrix : python-version : [ 3.7 , 3.8 , 3.9 ] steps : - uses : actions/checkout@v2 - name : Set up Python ${{ matrix.python-version }} uses : actions/setup-python@v2 with : python-version : ${{ matrix.python-version }} - name : Install dependencies run : | python -m pip install --upgrade pip python -m pip install poetry poetry config virtualenvs.in-project true poetry install # if [ -f requirements.txt ]; then pip install -r requirements.txt; fi - name : Lint with pylint run : | python lint.py --path ./pyconfme --threshold 2 continue-on-error : true - name : Test with pytest run : | ./.venv/bin/pytest --doctest-modules --html=test-results-${{ matrix.python-version }}.html --cov-report=html --cov=./pyconfme/ . continue-on-error : true - name : Upload pytest test results uses : actions/upload-artifact@v2 with : path : | test-results-${{ matrix.python-version }}.html assets/* - name : Upload test coverage results uses : actions/upload-artifact@v2 with : path : ./htmlcov # Use always() to always run this step to publish test results when there are test failures if : ${{ always() }} Initial content docs.yml name : Docs on : push : branches : - main jobs : deploy : runs-on : ubuntu-18.04 strategy : matrix : python-version : [ '3.9' ] steps : - uses : actions/checkout@v2 - name : Set up Python ${{ matrix.python-version }} uses : actions/setup-python@v2 with : python-version : ${{ matrix.python-version }} - name : Install dependencies run : | python -m pip install --upgrade pip python -m pip install poetry poetry config virtualenvs.in-project true poetry install - uses : actions-ecosystem/action-get-latest-tag@v1 id : get-latest-tag with : semver_only : true - run : | export PATH=\"$PATH:$PWD/.venv/bin\" git config --global user.name \"$(git --no-pager log --format=format:'%an' -n 1)\" git config --global user.email \"$(git --no-pager log --format=format:'%ae' -n 1)\" mike deploy --update-aliases ${{ steps.get-latest-tag.outputs.tag }} latest mike set-default latest - name : Deploy uses : peaceiris/actions-gh-pages@v3 with : github_token : ${{ secrets.GITHUB_TOKEN }} publish_dir : ./site The Github action described in .github/workflows/docs.yml is based on GitHub Actions for GitHub Pages , which builds and deploys mkdoc page structures and takes care that Github is serving those as is instead of using Jekyll. In the Github actions, the latest version is retrieved using get-latest-tag to build the latest documentation. While documentation updates including documentation versions on Github are automatically done based on latest tag information (see .github/workflows/Docs.yml ), you need to run the following to locally build and serve the versioned documentation for preview on https://localhost:8000 : mike deploy --update-aliases 0 .1.0 latest # replace 0.1.0 manually with the current version from pyconfme/__init__.py mike set-default latest mike serve You have to run both commands to get a proper redirect to the latest documentation on https://localhost:8000 . Refer to mkdocs-material documentation and to mike documentation for details. Instead of running mike deploy manually, you can use the poethepoet actions described earlier. Create a test-build of the documentation by changing into the virtual-environment and then using the poe build task for the documentation. poetry shell poe db","title":"Github Actions"}]}